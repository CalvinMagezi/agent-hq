import { FbmqPriority, ParsedHeaders } from "./types";

export interface PushOptions {
    priority?: FbmqPriority;
    ttl?: number;
    correlationId?: string;
    tags?: string[];
    createdBy?: string;
    custom?: Record<string, string>;
}

export class FbmqCli {
    private bin: string;
    private dir: string;

    constructor(dir: string, bin: string = "fbmq") {
        this.dir = dir;
        this.bin = bin;
    }

    private async run(args: string[], stdin?: string): Promise<{ stdout: string; exitCode: number }> {
        const procArgs = [this.bin, ...args];
        const proc = Bun.spawn(procArgs, {
            stdin: stdin ? new TextEncoder().encode(stdin) : undefined,
            stdout: "pipe",
            stderr: "pipe"
        });

        const stdout = await new Response(proc.stdout).text();
        const stderr = await new Response(proc.stderr).text();
        const exitCode = await proc.exited;

        if (exitCode !== 0 && exitCode !== 1) { // 1 is often used for empty queue in pop
            throw new Error(`Command failed: ${procArgs.join(" ")}\nStderr: ${stderr}`);
        }
        return { stdout, exitCode };
    }

    async init(usePriority: boolean = false): Promise<void> {
        const args = ["init", this.dir];
        if (usePriority) args.push("--priority");
        await this.run(args);
    }

    async push(body: string, opts: PushOptions = {}): Promise<string> {
        const args = ["push", this.dir];
        if (opts.priority) args.push("-p", opts.priority);
        if (opts.ttl !== undefined) args.push("-t", opts.ttl.toString());
        if (opts.correlationId) args.push("-c", opts.correlationId);
        if (opts.createdBy) args.push("-b", opts.createdBy);
        if (opts.tags) {
            for (const tag of opts.tags) {
                args.push("-T", tag);
            }
        }

        // fbmq push reads the body from stdin. Custom metadata is prepended as
        // an RFC 822-style continuation block that becomes part of the message body.
        // fbmq's own headers (Id, Priority, TTL, etc.) are generated by the CLI.
        let fullBody = "";
        if (opts.custom && Object.keys(opts.custom).length > 0) {
            fullBody += "Custom:\n";
            for (const [k, v] of Object.entries(opts.custom)) {
                fullBody += `  ${k}: ${v}\n`;
            }
            fullBody += "\n";
        }
        fullBody += body;

        args.push("-");

        const { stdout } = await this.run(args, fullBody);
        return stdout.trim(); // fbmq push prints 32-char message ID to stdout
    }

    async pop(): Promise<string | null> {
        const { stdout, exitCode } = await this.run(["pop", this.dir]);
        if (exitCode === 1 || !stdout.trim()) return null;
        return stdout.trim();
    }

    async ack(path: string): Promise<void> {
        await this.run(["ack", this.dir, path]);
    }

    async nack(path: string): Promise<void> {
        await this.run(["nack", this.dir, path]);
    }

    async depth(): Promise<number> {
        const { stdout } = await this.run(["depth", this.dir]);
        return parseInt(stdout.trim(), 10) || 0;
    }

    async cat(path: string): Promise<string> {
        const { stdout } = await this.run(["cat", path]);
        return stdout;
    }

    async inspect(path: string): Promise<ParsedHeaders> {
        const { stdout } = await this.run(["inspect", path]);
        // Parse fbmq inspect output â€” field names use spaces, not hyphens:
        //   ID:             <hex>
        //   Priority:       high
        //   Correlation ID: <string>
        //   Created by:     <string>
        //   Tags:           tag1,tag2
        //   Body:           NNN bytes
        const headers: ParsedHeaders = { custom: {}, raw: new Map() };

        for (const line of stdout.split('\n')) {
            if (!line.trim()) continue;

            const match = line.match(/^([^:]+):\s+(.*)$/);
            if (match) {
                const key = match[1].toLowerCase().trim();
                const val = match[2].trim();
                headers.raw?.set(key, val);

                switch (key) {
                    case 'priority': headers.priority = val.toLowerCase(); break;
                    case 'correlation id': headers.correlationId = val; break;
                    case 'ttl': headers.ttl = parseInt(val, 10); break;
                    case 'created by': headers.createdBy = val; break;
                    case 'tags': headers.tags = val.split(',').map(s => s.trim()); break;
                }
            }
        }
        return headers;
    }

    /**
     * Parse the Custom: block we prepend to the body during push.
     * Returns the extracted custom key-value pairs and the clean body
     * (with the Custom: block stripped).
     */
    static parseBodyCustom(rawBody: string): { custom: Record<string, string>; cleanBody: string } {
        const custom: Record<string, string> = {};

        if (!rawBody.startsWith("Custom:\n")) {
            return { custom, cleanBody: rawBody };
        }

        const lines = rawBody.split('\n');
        let i = 1; // skip "Custom:" line
        while (i < lines.length) {
            const line = lines[i];
            if (line.startsWith('  ')) {
                const match = line.trim().match(/^([^:]+):\s*(.*)$/);
                if (match) {
                    custom[match[1]] = match[2];
                }
                i++;
            } else {
                break;
            }
        }
        // Skip the blank line separator after the Custom block
        if (i < lines.length && lines[i].trim() === '') {
            i++;
        }
        const cleanBody = lines.slice(i).join('\n');
        return { custom, cleanBody };
    }

    async reap(leaseSecs?: number): Promise<void> {
        const args = ["reap", this.dir];
        if (leaseSecs !== undefined) args.push("-l", leaseSecs.toString());
        await this.run(args);
    }

    async purge(maxAgeSecs?: number): Promise<void> {
        const args = ["purge", this.dir];
        if (maxAgeSecs !== undefined) args.push("-a", maxAgeSecs.toString());
        await this.run(args);
    }

    async sync(): Promise<void> {
        await this.run(["sync", this.dir]);
    }
}
