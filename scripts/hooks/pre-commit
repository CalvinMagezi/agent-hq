#!/usr/bin/env bash
#
# Pre-commit hook: Scan staged files for secrets and sensitive data.
#
# Install:
#   git config core.hooksPath scripts/hooks
#
# Or symlink:
#   ln -sf ../../scripts/hooks/pre-commit .git/hooks/pre-commit
#
set -euo pipefail

RED='\033[0;31m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

BLOCKED=0

# Get list of staged files (added or modified)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM 2>/dev/null || true)

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

# 1. Block .env.local and other secret files from being committed
BLOCKED_PATTERNS='\.env\.local$|\.env\.production$|\.env\.development$|\.env\.staging$'
for file in $STAGED_FILES; do
    if echo "$file" | grep -qE "$BLOCKED_PATTERNS"; then
        echo -e "${RED}BLOCKED${NC}: $file — environment file with secrets must not be committed"
        BLOCKED=1
    fi
done

# 2. Scan staged file contents for API key patterns
# Common prefixes for API keys and tokens
SECRET_PATTERNS=(
    'sk-or-v1-[a-f0-9]{20,}'       # OpenRouter API key
    'sk-[a-zA-Z0-9]{20,}'           # OpenAI API key
    'gsk_[a-zA-Z0-9]{20,}'          # Groq API key
    'chq_[a-f0-9]{20,}'             # CloudHQ API key
    'xoxb-[0-9]+-[a-zA-Z0-9]+'      # Slack bot token
    'xoxp-[0-9]+-[a-zA-Z0-9]+'      # Slack user token
    'ghp_[a-zA-Z0-9]{30,}'          # GitHub personal access token
    'ghu_[a-zA-Z0-9]{30,}'          # GitHub user token
    'AKIA[0-9A-Z]{16}'              # AWS access key
    'AIzaSy[a-zA-Z0-9_-]{33}'       # Google API key
)

# Discord bot token pattern: base64-encoded user ID, timestamp, HMAC
DISCORD_TOKEN_PATTERN='[MN][A-Za-z0-9]{23,}\.[A-Za-z0-9_-]{6}\.[A-Za-z0-9_-]{27,}'

# Build combined grep pattern
COMBINED_PATTERN=$(IFS='|'; echo "${SECRET_PATTERNS[*]}")
COMBINED_PATTERN="$COMBINED_PATTERN|$DISCORD_TOKEN_PATTERN"

for file in $STAGED_FILES; do
    # Skip binary files, examples, and this hook itself
    if echo "$file" | grep -qE '\.(png|jpg|jpeg|gif|ico|woff|ttf|eot|svg|zip|tar|gz|pdf|lock)$'; then
        continue
    fi
    if echo "$file" | grep -qE '\.example$|pre-commit$'; then
        continue
    fi

    # Get staged content (not working tree content)
    CONTENT=$(git show ":$file" 2>/dev/null || true)
    if [ -z "$CONTENT" ]; then
        continue
    fi

    MATCHES=$(echo "$CONTENT" | grep -nEo "$COMBINED_PATTERN" 2>/dev/null || true)
    if [ -n "$MATCHES" ]; then
        echo -e "${RED}BLOCKED${NC}: $file — potential secret detected:"
        echo "$MATCHES" | head -3 | while read -r match; do
            # Truncate the match to avoid printing the full secret
            TRUNCATED=$(echo "$match" | cut -c1-40)
            echo -e "  ${YELLOW}$TRUNCATED...${NC}"
        done
        BLOCKED=1
    fi
done

# 3. Check for common secret variable assignments in non-example files
for file in $STAGED_FILES; do
    if echo "$file" | grep -qE '\.example$|\.md$'; then
        continue
    fi
    if echo "$file" | grep -qE '\.(ts|js|json|yaml|yml|toml|cfg|ini|conf)$'; then
        CONTENT=$(git show ":$file" 2>/dev/null || true)
        if [ -z "$CONTENT" ]; then
            continue
        fi

        # Look for hardcoded assignments (not process.env references)
        HARDCODED=$(echo "$CONTENT" | grep -nE '(API_KEY|SECRET|TOKEN|PASSWORD|PRIVATE_KEY)\s*[:=]\s*["\x27][^\s"'\'']{10,}' 2>/dev/null | grep -vE 'process\.env|import|require|example|placeholder|your_|changeme|xxx' || true)
        if [ -n "$HARDCODED" ]; then
            echo -e "${YELLOW}WARNING${NC}: $file — possible hardcoded secret:"
            echo "$HARDCODED" | head -3 | while read -r line; do
                echo "  $line"
            done
            BLOCKED=1
        fi
    fi
done

if [ "$BLOCKED" -eq 1 ]; then
    echo ""
    echo -e "${RED}Commit blocked${NC}: Potential secrets detected in staged files."
    echo "If this is a false positive, bypass with: git commit --no-verify"
    exit 1
fi

exit 0
